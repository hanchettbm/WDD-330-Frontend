<!DOCTYPE html>
<html lang='en-us'>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WDD330 Week 10</title>
    <meta name="description" content="My notes page for WDD 330 week 4." />
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
    <main>
        <h1>MDN: Validating Forms and Using Fetch</h1>
        <hr>
        <h2>Week 11 notes and reading</h2>
        <ul>
            <li>
                Before submitting data to the server, it is important to ensure all required form controls are filled out, in the correct format. This is called client-side 
                form validation, and helps ensure data submitted matches the requirements set forth in the various form controls. This is why the required tag on an input form 
                is so crucial. 
            </li>

            <li>
                Client-side validation should not be considered an exhaustive security measure!! You should always have more then one type of error checking. For client side validation 
                you can check if the form input is the right format (Pasword, email must contain '@' etc.) or make it required meaning the user can not leave it blank. These are specifially 
                for forms. If the information is correctly formatted, the application allows the data to be submitted to the server and (usually) saved in a database; if the information isn't 
                correctly formatted, it gives the user an error message explaining what needs to be corrected, and lets them try again. This is built in. 
            </li>

            <li>
                Although we want to make filling forms as easy as possible we also have to make sure we are getting the right data, otherwise it's pointless. 
                JavaScript also has customizable validation. HTML built in validation includes: required, minlength, maxlength, pattern, invalid, etc. 
                *For good user experience, indicate to the user when form fields are required.  the pattern attribute, which expects a Regular Expression
                as its value. A regular expression (regex) is a pattern that can be used to match character combinations in text strings. You can also constrain 
                the form (i.e. input type="number") and use a min and max value. 
            </li>


            <li>
               Javascript can also use more specific error checking and we can do it using event listners. we store a reference to the email input, then add an event listener to 
               it that runs the contained code each time the value inside the input is changed. As you can see, it's not that hard to build a validation system on your own. The 
               difficult part is to make it generic enough to use both cross-platform and on any form you might create.
            </li>

            <li>
                Always remember to help your users correct the data they provide Display explicit error messages. Be permissive about the input format. Point out exactly where the 
                error occurs, especially on large forms.
            </li>

            <li>
                The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global 
                fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.
            </li>

            <li>
                The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global 
                fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.
            </li>

            <li>    
                The simplest use of fetch() takes one argument — the path to the resource you want to fetch — and does not directly return the JSON response body but instead returns a 
                promise that resolves with a Response object. The Response object, in turn, does not directly contain the actual JSON response body but is instead a representation of 
                the entire HTTP response. So, to extract the JSON body content from the Response object, we use the json() method, which returns a second promise that resolves with the 
                result of parsing the response body text as JSON. You can also Use fetch() to POST (send) JSON-encoded data.
            </li>
            
            <li>
                It is also important to check if the POST was sucessful and have an error check in response. Headers give details about what you are sending, and how it should be sent. 
                A good use case for headers is checking whether the content type is correct before you process it further. Since headers can be sent in requests and received in responses, 
                and have various limitations about what information can and should be mutable, headers' objects have a guard property. 
                The most common response properties you'll use are: Response.status — An integer (default value 200) containing the response status code. Response.statusText — A string 
                (default value ""), which corresponds to the HTTP status code message. Note that HTTP/2 does not support status messages. Response.ok — seen in use above, this is a shorthand 
                for checking that status is in the range 200-299 inclusive. This returns a boolean value.
            </li>
        <ul>

        <h2>Code Examples</h2>
        <ul>
            <li><a href="fruitvalidation.html">Fruit Validation Example</a></li>
            <li><a href="fetch.html">Fetch API Example</a></li>
        </ul>

        <h2>Questions</h2>
            <ul>
                <li>How is accsessing the browser window data different from accessing the session data, or are they linked?</li>
                <li>How do you keep up on API updates?</li>
                <li>Are the laws and limits to cookie and browsing data? What can we not track?</li>
                <li>Is it better to work with native or server information instead of the browser?</li>
    </main>
</body>
</html>